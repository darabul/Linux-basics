# Отчет по проекту Linux

## Part 1
* чтобы проверить текущую версию системы, воспользуемcя командой `cat /etc/issue`  

    ![](./screen/part1.PNG)   

## Part 2
* чтобы создать нового пользователя, воспользуемся командой `sudo useradd artem`
* чтобы добавить пользователя в группу, воспользуемся командой `sudo usermod -a -G adm artem`
* чтобы проверить имеющихся пользователей, воспользуемся командой `cat /etc/passwd`  

    ![](./screen/part2.PNG)

## Part 3
* что задать название машине воспользуемся командой `sudo nano etc/hostname` и изменим webserver на user-1, чтобы изменения вступили в силу, воспользуемся командой `sudo reboot`  
    ![](./screen/part3.1.PNG)

*   1. чтобы установить временную зону, соответствующую вашему текущему местоположению, нужно сначала выполнить команду `timedateclt list-zones`, с помощью которой мы выбрем временную зону. В нашем случае Europe/Moscow.  
    ![](./screen/part3.2.PNG)

    2. теперь устанавливаем временную зону командой  `sudo timedatectl set-timezone Europe/Moscow`
    3. посмотрим результат работы командой `timedatectl`
    ![](./screen/part3.3.PNG)

* чтобы вывести названия всех сетевых интерфейсов, воспользуемся командой `ip link show`  
![](./screen/part3.4.PNG)
или  
воспользуемся командой `ifconfig -a`
    ![](./screen/part3.4.1.PNG)

    Обратим внимание на интерфейс lo.  
    Что это такое?
    Это виртуальные интерфейс (существует на уровне операционной системы). Он используется для запуска и отладки сетевых программ и серверных приложений на локальной машине.  

* чтобы получить ip адрес от DHCP сервера, нужно, сперва, установить DHCP на вашу систему. Для этого введем следущий набор команд:  
    1. обновим пакетный менеджер командой  
     `sudo apt-get update`
    2. установим dhcp сервер командой  
    `sudo apt-instal isc-dhcp-server -y`  
    3. чтобы получить ip от DHCP сервера воспользуемся командодй  
    `sudo dhclient -v`   
    ![](./screen/part4.1.PNG)
    DHCP - Dynamic Host Configuration Protocol. Нужен для того, чтобы автоматически выдавать динамические ip адреса устройствам в сети.

*   1. чтобы узнать внутренний ip адрес(адрес, который нужен, чтобы программы могли взаимодействовать в рамках одного компьютера, используя сетевые протоколы), воспользуемся командой  
    `ping localhost`   
    ![](./screen/5.1.PNG)

    2. чтобы узнать внешний ip адрес (адрес, который используется для выхода в глобальную сеть, бывает статическим и динамическим), воспользуемся командой  
    `curl ifconfig.me`
    ![](./screen/5.2.PNG)
* DNS - это некоторый протокол, который позволяет находить пользовательский запрос через браузеры тип firefox, chrome в интернете. Он сопоставляет IP адрес с некоторым понятным буквенным адресом  
пример : 192.103.104.245 - www.bigbang.com
    1. чтобы вручную настроить ip, gw, dns выполним команду `sudo nano /etc/netplan/00-installer-config.yaml` и установим необходимые значения. Пример настройки конфига на скриншоте:
    ![](./screen/6.1.PNG) 
    2. чтобы изменения вступили в силу, воспользуемся командой `sudo netplan apply`  
* Проверим, что настройки сети, которые мы поставили в прошлом пункте сохранились
    1. сначала воспользуемся командой `sudo reboot`, чтобы перезагрузить систему
    2. теперь чтобы проверить сохранились ли наши настройки, воспользуемся командами  
        ```
        ip a
        resolvectl dns
        ip route | grep default
        ```
        ![](./screen/6.2.PNG)
    3. теперь пропингуем удаленные хосты 
    1.1.1.1, 8.8.8.8 и ya.ru   
        ![](./screen/6.3.PNG)  
        как видим потери пакетов не обнаружено.

## Part 4
* 1. обновим список пакетов для загрузки командой  
`sudo apt-get update`  
    ![](./screen/part4.1.PNG)
  2. обновим установленные пакеты командой  
  `sudo apt-get upgrade`  
  3. введем эту команду повторно, убеждаемся что все обновилось 
    ![](./screen/part4.2.PNG)

## Part 5
* sudo - это программа для системного администрированния UNIX систем. Основная идея - это дать пользователям как можно меньше прав, но достаточных для выполнения поставленных задач
* 1. дадим права sudo пользователю artem с помощью команды  
`sudo usermod -aG sudo artem`  
и проверим, что artem получил права sudo, командой `id artem`
    ![](./screen/part5.1.PNG)
    2. чтобы поменять пользователя, воспользуемся командой `su artem`
    3. используем команду `sudo nano /etc/hostname` и меняем значение user-1 -> user-2
    4. чтобы изменения вступили, перезагрузим систему командой
    `sudo reboot`
    ![](./screen/part5.2.PNG)

## Part 6
* 1. чтобы вывести текущее время, воспользуемся командой `timedatectl`
  2. проверим синхронизацию времени командой `timedatectl show`
  ![](./screen/part6.PNG)

## Part 7
* чтобы установить текстовые редакторы воспользуемся командой  
`sudo apt-get install vim nano joe`

* 1. - создадим текстовый файл командой `nano test_nano.txt`
     - в открывшемся редакторе nano напишем свой ник 
     - чтобы сохранить изменения воспользуемся сочетанием клавиш CTRL + S
     - чтобы закрыть файл воспользуемся сочетанием клавиш CTRL + X
    ![](./screen/part7.1.nano.PNG)
  2. - создаем текстовый файл командой `vim test_vim.txt`
     - в открывшемся редакторе vim пишем свой ник
     - чтобы сохранить изменения и выйти, воспользуемся клавишей ESC, и в командной строке напишем :qw
     ![](./screen/part7.1.vim.PNG)
  3. - создаем текстовый файл командой `joe test_joe.txt`
     - в открывшемся редокторе joe пишем свой ник 
     - чтобы сохранить изменения и выйти, воспользуемся сочетанием клавиш CTRL + K + X
     ![](./screen/part7.1.joe.PNG)

* 1. - откроем имеющийся текстовый файл командой `nano test_nano.txt`
     - вписываем туда `21 School 21`
     - выходим без сохранения изменений с помощью сочетания клавиш CTRL + X, а после нажимаем клавишу N 
     ![](./screen/part7.2.nano.PNG)
  2. - откроем имеющийся текстовый файл командой `vim test_vim.txt`
     - вписываем туда `21 School 21`
     - чтобы выйти без сохранения изменений, перейдем в командный режим, нажав клавишу ESC и вписав в командную строку `q!` 
     ![](./screen/part7.2.vim.PNG)
  3. - откроем имеющийся текстовый файл командой `joe test_joe.txt`
     - вписываем туда `21 School 21`
     - выходим без сохранения изменений с помощью сочетания клавиш CTRL + C, а после нажимаем клавишу Y
     ![](./screen/part7.2.joe.PNG)

* 1. - откроем имеющийся текстовый файл командой `nano test_nano.txt`
     - вписываем туда `rockguy crockgruy`
     - чтобы осуществить поиск без изменения, воспользуемся сочетанием клавиш CTRL + W, в открывшейся строке записываем строку, которую хотим найти, нажимаем клавишу ENTER
     - чтобы осуществить посик с заменой, воспользуемся сочетанием клавиш ALT + R, в открывшейся строке записываем строку, которую хотим заменить, после в новой открывшейся строке записываем строку, на которую хотим заменить
     ![](./screen/part7.3.1.nano.PNG)
     ![](./screen/part7.3.2.nano.PNG)
     ![](./screen/part7.3.3.nano.PNG)
     ![](./screen/part7.3.4.nano.PNG)
  2. - откроем имеющийся текстовый файл командой `vim test_vim.txt`
     - вписываем туда `rockguy crockgruy`
     - чтобы осуществить поиск без изменений, переходим в командный режим, а дальше вписываем в командую строку `/guy` 
     - чтобы осуществить поиск с изменениями, переходим в командный режим, а дальше вписываем в командную строку `:s/crock/guy`
     ![](./screen/part7.3.1.vim.PNG)
     ![](./screen/part7.3.2.vim.PNG)
  3. - откроем имеющийся текстовый файл командой `joe test_joe.txt`
     - вписываем туда `rockguy crockgruy`
     - чтобы осуществить поиск без замены, воспользуемся сочетанием клавиш CTRL + K + F, и в предложенной строке нажмем на клаву I
     - чтобы осуществить поиск с заменой, воспользуемся сочением клавиш CTRL+K+F, и в предложенно окне нажмем на клавишу R
     ![](./screen/part7.3.1.joe.PNG)
     ![](./screen/part7.3.2.joe.PNG)


## Part 8
* чтобы установить службу sshd, воспользуемся командами:   
`sudo apt-get install ssh`  
`sudo apt install openssh-server`
* чтобы добавить службу в автозагрузку системы воспользуемся командой  
`sudo systemctl enable ssh.service`
* чтобы поменять порт на 2022, воспользуемся командой  
`sudo nano etc/ssh/sshd_config`
![](./screen/part8.1.PNG)
* чтобы проверить, что наша служба находится в автозагрузке, воспользуемся командой 
`ps aux | grep sshd`
![](./screen/part8.2.PNG)
    Опция `a` указывает ps вывести на дисплей процессы всех пользователей, за исключением тех процессов, которые не связаны с терминалом и процессами группы лидеров.  

    В `u` — подставки для ориентированных на пользователя формате, который обеспечивает подробную информацию о процессах.  

    Опция `x` в ps перечисляет процессы без управляющего терминала. В основном это процессы, которые запускаются во время загрузки и работают в фоновом режиме.

* перезагружаем систему командой `sudo reboot`
* введем команду `netstat -tan`
![](./screen/part8.3.PNG)
  - netstat - это утилита, которая позволяет выводить на экран состояние TCP соединений, число сетевых интерфейсов и сетевую статистику по протоколам.
   Зачем использовать? 
   Чтобы находить и устранять проблемы в сетевых соединениях и мониторить их производительность  
   `-t - отобразить только активные TCP-соединения`  
   `-a - отобразить список прослушивающих и непрослушивающих сокетов`  
   `-n - вывод будет осуществляться в символической форме. К примеру localhost:domain отображаться как на 127.0.0.53`  
    Proto - Протокол (tcp, udp, raw),используемый сокетом.  

    Recv-Q - Счётчик байт не скопированных программой пользователя из этого сокета.  

    Send-Q - Счётчик байтов, не подтверждённых удалённым узлом.  

    Local Address - Адрес и номер порта локального конца сокета. Если не указана опция --numeric (-n), адрес сокета преобразуется в каноническое имя узла (FQDN), и номер порта преобразуется в соответствующее имя службы.

    Local Address 0.0.0.0 - означает прослушивание на всех устройствах.

    Foreign Address - 
    Адрес и номер порта удалённого конца сокета. Аналогично "Local Address."

    Foreign Address 0.0.0.0 - это означает, что никто не подключился


    State - Состояние сокета. Поскольку в режиме raw нет состояний, а в режиме UDP состояния обычно не испольуются, эта колонка может оставаться пустой.

    LISTEN - Сокет ожидает входящих подключений. Такие сокеты не включаются в вывод, пока вы не укажете опцию `-a`

    TCP — это протокол управления передачей (Transmission Control Protocol). Его задача — управлять отправкой данных и следить за тем, чтобы они были гарантированно приняты получателем. Именно гарантия получения данных и сделала этот протокол таким востребованным.

## Part 9 

* uptime = 14 min - время непрерывной работы   
    user = 1 - количество авторизованных пользователей  
    load average - общая загрузка системы. Она показывает среднее использование ресурсов процессора на протяжении времени.   
        - 0,10 - средняя нагрузка в течение 1 минуты   
        - 0,12 - средняя нагрузка в течение 5 минут  
        - 0,11 - средняя нагрузка в течении 15 минут  
    Tasks = 101 - общее число процессов   
    %CPU(s) - загрузка CPU в %   
        - 0,0 us - пользователями  
        - 0,3 sy - системой   
    MiB Mem - память   
        - 3920,2 total - используется  
        - 3034,5 free -  свободная   
    PID = 1 - занимает больше всего памяти (столбец  %MEM)  
    PID = 1585 - занимает больше всего процессорного времене (столбец TIME+)
![](./screen/part9.1.PNG)

* отсортированному по PID, PERCENT_CPU, PERCENT_MEM, TIME
![](./screen/PID.png)
![](./screen/PER_CPU.png)
![](./screen/PER_MEM.png)
![](./screen/TIME.png)  

    отфильтрованному для процесса sshd
    ![](./screen/sshd.png)  
    с процессом syslog, найденным, используя поиск  
    ![](./screen/syslog.png)  
    с добавленным выводом hostname, clock и uptime  
    ![](./screen/hostname_clock_uptime.PNG)

## Part 10
- название жесткого диска = /dev/sda  
- размер жесткого диска = 15 GiB  
- количество секторов = 31457280  
- размер swap = отсутствует 
![](./screen/fdisk.PNG)

## Part 11
*   - размер раздела = 10218772  
    - размер занятого пространства = 3380076 
    - размер свободного пространства = 6298024
    - процент использования = 25 
    - единица измерения = Kbytes
    ![](./screen/df.PNG)

*   - размер раздела = 9,8
    - размер занятого пространства = 3,3
    - размер свободного пространства = 6,1
    - процент использования = 35
    - единица измерения = Gbytes
    - тип файловой системы = ext4
    ![](./screen/df_th.PNG)

## Part 12
* Вывести размер папок /home, /var, /var/log (в байтах, в человекочитаемом виде)
![](./screen/du_home.PNG)
![](./screen/du_var.png)
![](./screen/du_var_log.PNG)
* Вывести размер всего содержимого в /var/log (не общее, а каждого вложенного элемента, используя *)
![](./screen/du_var_log_star.png)

## Part 13
* чтобы установить утилиту, воспользуемся командой `sudo apt-get install ncdu`  

    - размер папки /home 
    ![](./screen/ncdu_home.PNG)
    - размер папки /var
    ![](./screen/ncdu_var.PNG)
    - размер папки /var/log
    ![](./screen/ncdu_var_log.PNG)

## Part 14 
* время последней успешной авторизации: 14:29:45  
  имя пользователя:  darabul  
  метод входа в систему: login  
![](/screen/14_log.PNG)

* - перезапустим службу sshd командой   
`sudo systemctl restart sshd.service`
  - посмотрим сообщение в логах командой  
  `cat ../../var/log/syslog`
![](./screen/14_2.PNG)

## Part 15 
* чтобы установить синхронизацию времени каждые 2 минуты, воспользуемся командой `crontab -e`
![](./screen/crontab.1.PNG)
посмотрим работу cron с помощью команды `tail /var/log/syslog`  
видим, что через 2 минуты запустилась синхронизация времени
    ![](./screen/cron_2.PNG)
выведем список текущих задач cron командой `crontab -l`  
![](./screen/cron_3.PNG)
 
 * удалим все задачи из планировщика cron командой `crontab -r` и проверим, что в нем больше нет записей командой `crontab -l`  
 ![](./screen/cron_last.PNG)











  




 